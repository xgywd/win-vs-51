/******************************头文件加载与宏定义**************************************************/
#include <reg52.h>                 
																		/*用于声明特殊功能寄存器的名称.
																		如果没有这个头文件，特殊功能寄存器，只能用硬件的地址进行读写操作。*/

typedef  unsigned int uint;
typedef  unsigned char uchar;
/******************************声明全局函数和变量*********************************************************/
/*此处增加其它全局声明*/

void init();	//1602初始化函数
void chushi();	//串口初始化
void wcom(uchar com); //写指令
void wdat(uchar dat);	//写数据

uchar volatile flag=0;	//读入字符个数
void delay(uint i);
uchar pulse_dly=0;

bit text=0;	//显示标志

sbit rs=P1^0;
sbit rw=P1^1;
sbit e=P1^2;

uchar table1[32]={0};//缓冲


/**************************************主函数*************************************************/
void main()
{
	
	/*C51所有变量声明必须在代码段前*/

	uchar i;
	/*此处增加其它局部声明*/
	
	chushi();
	
	init();
	
	while(1)
	{
		if(text) //字符接收结束后开始显示
		{
			wcom(0x01);		//清屏光标回归00
			delay(1);		//清屏需要延时
			for(i=0;i<flag;i++)		//开始显示,
			{
				if(16==i)	//如果显示达到16个字符.换行
				{
					wcom(0x80+0x40);	//换行语句
				}
				wdat(table1[i]);	//显示当前字符
			}
			wcom(0x80);		//光标回归00
			text=0;		
			flag=0;
		}
	}
	
}
void chushi() 
{
		
/************************************定时器初始化***************************************************/
	
	TMOD=0x21;		/*0000 0001   TMOD 是计时器工作方式寄存器,有8位
	
									高四位设置定时器1.低四位定时器0. 两者设置相同.
									
									低四位0001 
									低两位01 代表方式1:16位寄存器
									{00	代表方式0:13位寄存器(高8,低5).
									10	代表方式3:8位自动重装定时:高8位溢出后,	
									低8位数值自动装入高8位做为初值.
									11	代表方式4:分为两个单独的8位定时/计数器}. 
									最高位0代表:GATE位(0不受中断控制,1受中断控制),
									第二位代表:CT位(选择0为定时器,选择1为计数器)*/
	/*********************************定时器加载初值******************************************************/
	
	TH0=(65536-500)/256;	/*定时器0是由两个8位寄存器TH0与TL0组成,
							  定时器初值计算方法为65536减去定时间隔除以256放入高8位,*/
	TL0=(65536-500)%256;	/*再用65536减去定时间隔取余256放入低8位*/
	TH1=0xfd;
	TL1=0xfd;

/**********************************开中断****************************************************/
	


	
	ET0=1; //开定时器0中断
	TR0=1;	//启动定时器0 
	//ET1=1;	//开定时器1中断,串口通信中,开启波特率的定时器不要打开定时器中断,如果打开中断,就要写对应的中断服务程序.
	TR1=1;	//启动定时器1
	
	
/***************************************************************************************/	

	//SCON= B01010000; 
				/*SCON有8位
				SM0=SCON^7,
				SM1=SCON^6
					(SM0与SM1是串口工作方式选择共有四种模式
					00:移位寄存器,波特率为晶振频率fosc/12,
					01:10位异步收发器,8位数据,波特率可变  (比较常用)
					10:11位异步收发器,9位数据,波特率为晶振频率fosc/64或32
					11:11位异步收发器,9位数据,波特率可变).
				SM2=SCON^5,
					多机通信控制位,SM2=1;时,利用收到的RB8来控制是否激活RI,SM2=0;时无论RB8收到何种数据,都会激活RI
				REN=SCON^4,
					允许串行接收位,REN=1;时,允许接收 0时禁止接收数据
				TB8=SCON^3,
					方式2-3中,通信数据的第9位.可做奇偶校验位.在多机通信中作为地址帧数据帧的标志位.
				RB8=SCON^2;
					方式2-3中,通信数据的第9位.SM2=1;时控制是否激活RI,方式1时,SM2=0时,接收到的是停止位.
				TI=SCON^1;
					发送中断标志位.方式0时,当第8位数据发送结束时,或在其它方式串行发送停止位开始时,向CPU发送中断申请,中断处理函数中必须对其清0,取消此中断申请.
				RI=SCON^0;
					接收中断标志位.方式0时,当第8位数据接收结束时,或在其它方式串行接收停止位中间时,向CPU发送中断申请,中断处理函数中必须对其清0,取消此中断申请.*/
	SM0=0;
	SM1=1;
	REN=1;
	ES=1;	//打开串口中断
	
	EA=1;	//开总中断 	
	//PT0=1;
	
			/* 打开定时器0的执行优先级
	
			IP  执行优先级寄存器IP,如果不设置IP,中断只具有查询优先级.高中断优先级函数不会打断正在执行的中断服务函数,
			sbit PT2   = IP^5;    //定时器2:C/T2
			sbit PS    = IP^4;	//串口中断	
			sbit PT1   = IP^3;	//定时器0
			sbit PX1   = IP^2;	//外部中断1
			sbit PT0   = IP^1;	//定时器0
			sbit PX0   = IP^0; 	//外部中断1
			*/
		PS=1;    //打开串口中断执行优先级
}
void init ()
{
	delay(30);
	wcom(0x38);
	delay(10);
	wcom(0x38);
	delay(10);
	wcom(0x38);
	wcom(0x38);
	wcom(0x08);
	wcom(0x01);
	wcom(0x06);
	wcom(0x0c);
}
void wcom(uchar com)
{
	rs=0;
	rw=0;
	P0=com;
	delay(2);
	e=1;
	e=0;
}
void wdat(uchar dat)
{
	rs=1;
	rw=0;
	P0=dat;
	delay(2);
	e=1;
	e=0;	
}

void delaytime() interrupt 1
{
	TH0=(65536-500)/256;
	
	TL0=(65536-500)%256;
	
	pulse_dly++;

}


void delay(uint i)
{
	pulse_dly=0;
	while(i!=pulse_dly);
}

void serial() interrupt 4
{
	if(flag<32)
	{
		table1[flag]=SBUF;      //向缓冲区写数据.
		flag++; 
	}
	if(' '==SBUF)	//如果遇到空格,显示开始
	{
		text=1;		//打开显示标记
		RI=0;
		return;
	}	
	RI=0;
}



