/********************************头文件设置**********************************************/

#include<reg52.h>						//将reg52.h文件作为头文件放入程序

/********************************宏定义**********************************************/

#define uint unsigned int				//将无符号整型宏定义为uint
#define uchar unsigned char				//将无符号字符型宏定义为uchar

/************************************位定义**********************************************/

sbit duan=P2^6;							//设置P2.6端口为变量duan,控制段码锁存器的锁存端
sbit wei=P2^7;							//设置P2.7端口为变量wei，控制位码锁存器的锁存端

/********************************字符定义**********************************************/

uchar code duanma[]={					//定义一个无符号字符串duanma[]存入ROM
0x3f,0x06,0x5b,0x4f,					//用于共阴极数码管段码的数据表格
0x66,0x6d,0x7d,0x07,					//按照LED发光二极管的排列和需要数字的排列编码
0x7f,0x6f,0x77,0x7c,					//发光取高电平，熄灭取低电平
0x39,0x5e,0x79,0x71};					// 例如duanma[0]就等于0x3f

uchar code weima[]={					//定义一个无符号字符串weima[]存入ROM
0xfe,0xfd,0xfb,0xf7,					//用于共阴极数码管位码的数据表格
0xef,0xdf,0xbf,0x7f};					//按照数码管的排列编码，发光取低电平，熄灭取高电平

uchar a,b,c;						//定义无符号字符变量，实际参数a,b,c
uint num;							//无符号整型变量，实际参数num

/********************************子函数申明**********************************************/

void delay(uint z);					  	//延时函数申明
void display(uchar bai,uchar shi,uchar ge);//数码显示函数声明

/********************************主函数**************************************************/

void main()								//无返回值主函数，有且只有一个
{
	num=520;							//num赋值520
	while(1)							//while（1）循环，括弧内非0即为真（不会跳出去）
	{									//并执行{}内语句
										//只有括弧内为0（0即为假），跳出且不再执行{语句}
		  display(a,b,c);				//显示函数，将实际参数a,b,c赋予形式参数bai,shi,ge
	}									//主函数要用大循环来循环扫描数码管，实时显示num
}

/********************************延时函数***********************************************/

void delay(uint z) //定义无返回值函数delay()，定义无符号整型变量z，为局部变量，形式参数
{
	uint x,y;							 //定义无符号整型变量x,y；该变量为局部变量，形参
	for(x=z;x>0;x--)					 //for循环   for（表达式1；表达式2；表达式3）
		for(y=110;y>0;y--);				 //			{语句（内部可为空）}
}	//这是for循环嵌套函数，
	//当y减到0，执行一次x--（将x减一再赋给x），最终计算次数为x乘以y，达到延时目的
	//执行过程；1.求解表达式1
	//			2.求解表达式2，若其值为真（非0即为真），
	//则执行for语句，然后执行第三步，否则结束for语句，直接跳出，不再执行第三步。
	//			3.求解表达式3	4.跳到第二步重复执行

/********************************显示函数**********************************************/

void display(uchar bai,uchar shi,uchar ge)//定义无返回值，局部变量，形式参数bai,shi,ge
{

	a=num/100;							 //num除以100的商，即分解出num的百位数赋给a
	b=num%100/10;						 //num除以100的余数，再除以10的商，分解十位数给b
	c=num%10;							 //num除以10的余数，即分解出个位数给c

	P1=duanma[bai];						 //操作P1口输出duanma[]第bai+1位的数据作为段码
	duan=1;								 //打开段码锁存端
	duan=0;								 //关闭段码锁存端
	P1=weima[5];						 //P1输出weima[]第6位数据作为位码，选第6个数码管
	wei=1;								 //打开位码锁存端
	wei=0;								 //关闭位码锁存端
	delay(1);							 //设置z=1，计算所用时间作为延时
	P1=0xff;							 //P1全部输出高电平，当位码锁存打开，达到消隐目的
	wei=1;								 //打开位码锁存端
	wei=0;								 //关闭位码锁存端

	P1=duanma[shi];						 //P1口输出duanma[]第shi+1位数据作为段码
	duan=1;								 //打开段码锁存端
	duan=0;								 //关闭段码锁存端
	P1=weima[6];						  //输入weima[]第7位数据作为代码，选第7个数码管
	wei=1;								 //位码锁存打开
	wei=0;								  //关闭位码锁存
	delay(1);							  //延时
	P1=0xff;							 //P1全部高电平，等待位码锁存打开，实现消隐
	wei=1;								 //位码锁存打开
	wei=0;								  //关闭位码锁存

	P1=duanma[ge];						   //程序作用同上，几个数码管连续循环扫描。
	duan=1;								  //实际上同一时间只能显示一个数码管
	duan=0;								  //微观上讲，是一个接着一个亮一段时间然后熄灭
	P1=weima[7];						  //这就是数码管动态扫描
	wei=1;								  //从而实现让人客观上认为是同时显示
	wei=0;
	delay(1);
	P1=0xff;
	wei=1;
	wei=0;								   //注意啊，软件仿真这种接法要先赋值再开锁存

}